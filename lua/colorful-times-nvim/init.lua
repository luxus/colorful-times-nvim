--- Colorful Times Plugin
---
--- A Neovim plugin that automatically changes your colorscheme based on a schedule, system settings, or manually.
---
--- This module can be loaded with `require('colorful-times')`.
---
--- Generated by OpenAI o1.
---

---@class ColorfulTimes
local M = {}

--- Plugin configuration.
---@type ColorfulTimes.Config
M.config = {
	schedule = {},
	default = {
		colorscheme = "default",
		background = "system",
	},
	enabled = true,
	refresh_time = 5000, -- Default refresh time in milliseconds
	system_background_detection = nil, -- Custom system background detection for Linux.
}

-- Keep track of the previous system background.
---@type string|nil
local previous_background

-- Cache for parsed schedule times.
---@type ColorfulTimes.ParsedScheduleEntry[]
local parsed_schedule = {}

-- Timer handles.
---@type uv_timer_t|nil
local timer
---@type uv_timer_t|nil
local appearance_timer

-- Import vim.loop
local uv = vim.loop

-- Define uv types for the Lua language server.
-- These definitions help the language server understand 'uv' functions.

---@class uv_timer_t
---@field start fun(self: uv_timer_t, timeout: number, repeat_interval: number, callback: function)
---@field stop fun(self: uv_timer_t)
---@field close fun(self: uv_timer_t)
local uv_timer_t = {}

---@class uv_pipe_t
---@field read_start fun(self: uv_pipe_t, callback: function)
---@field read_stop fun(self: uv_pipe_t)
---@field close fun(self: uv_pipe_t)
local uv_pipe_t = {}

---@class uv_process_t
---@field close fun(self: uv_process_t)
local uv_process_t = {}

---@class uv
---@field new_timer fun(): uv_timer_t
---@field new_pipe fun(ipc: boolean): uv_pipe_t
---@field spawn fun(path: string, options: table, on_exit: fun(code: number, signal: number)): uv_process_t
---@field os_uname fun(): { sysname: string }
uv = vim.loop

-- Proceed with your plugin code.

-- Schedule Entry.
---@class ColorfulTimes.ScheduleEntry
---@field start string Start time in "HH:MM" format.
---@field stop string Stop time in "HH:MM" format.
---@field colorscheme string Name of the colorscheme to apply.
---@field background? string "light", "dark", "system", or nil.

-- Parsed Schedule Entry.
---@class ColorfulTimes.ParsedScheduleEntry
---@field start_time integer Start time in minutes since midnight.
---@field stop_time integer Stop time in minutes since midnight.
---@field colorscheme string Name of the colorscheme to apply.
---@field background string "light", "dark", or "system".

-- Default Configuration.
---@class ColorfulTimes.DefaultConfig
---@field colorscheme string Default colorscheme when no schedule matches.
---@field background string "light", "dark", or "system".

-- Plugin Configuration.
---@class ColorfulTimes.Config
---@field schedule ColorfulTimes.ScheduleEntry[] Array of schedule entries.
---@field default ColorfulTimes.DefaultConfig Default colorscheme and background.
---@field enabled boolean Whether the plugin is enabled.
---@field refresh_time integer The refresh time in milliseconds for checking the system background.
---@field system_background_detection? string|fun():string Custom command or function to detect system background on Linux.

-- Helper function to parse time strings into minutes since midnight.
---@param time_str string Time string in "HH:MM" format.
---@return integer|nil Minutes since midnight or nil if invalid.
local function parse_time(time_str)
	local hour, min = time_str:match("^(%d%d?):(%d%d)$")
	if not hour or not min then
		return nil
	end
	hour = tonumber(hour)
	min = tonumber(min)
	if hour >= 24 or min >= 60 then
		return nil
	end
	return hour * 60 + min
end

-- Pre-process and cache parsed schedule times.
local function preprocess_schedule()
	parsed_schedule = {} -- Always re-parse the schedule to ensure the latest configuration is used.
	for idx, slot in ipairs(M.config.schedule) do
		local start_time = parse_time(slot.start)
		local stop_time = parse_time(slot.stop)
		if not start_time or not stop_time then
			vim.api.nvim_err_writeln(string.format("Invalid time format in schedule entry %d", idx))
		else
			-- Set background to default if not specified.
			local background = slot.background or M.config.default.background
			table.insert(parsed_schedule, {
				start_time = start_time,
				stop_time = stop_time,
				colorscheme = slot.colorscheme,
				background = background,
			})
		end
	end
end

-- Timer utility functions.
local function create_timer()
	return uv.new_timer()
end

local function stop_and_close_timer(timer_handle)
	if timer_handle then
		timer_handle:stop()
		timer_handle:close()
	end
end

-- Get current time in minutes since midnight.
---@return integer Minutes since midnight.
local function get_current_time()
	local date_table = os.date("*t")
	return (date_table.hour * 60) + date_table.min
end

-- Function to get the system background.
---@param callback fun(background: string)
---@param fallback string The fallback background value.
local function get_system_background(callback, fallback)
	local sysname = uv.os_uname().sysname or "Unknown"

	local function handle_spawn_result(code)
		vim.schedule(function()
			if code == 0 then
				callback("dark")
			else
				callback("light")
			end
		end)
	end

	if sysname == "Darwin" then
		-- macOS implementation using 'defaults' command.
		local stdout = uv.new_pipe(false)
		local stderr = uv.new_pipe(false)
		local handle
		handle = uv.spawn("defaults", {
			args = { "read", "-g", "AppleInterfaceStyle" },
			stdio = { nil, stdout, stderr },
		}, function(code, _signal)
			stdout:read_stop()
			stderr:read_stop()
			stdout:close()
			stderr:close()
			handle:close()
			handle_spawn_result(code)
		end)
	elseif sysname == "Linux" then
		if M.config.system_background_detection then
			local background = nil
			if type(M.config.system_background_detection) == "string" then
				-- Assume it's a command.
				local stdout = uv.new_pipe(false)
				local stderr = uv.new_pipe(false)
				local handle
				handle = uv.spawn("sh", {
					args = { "-c", M.config.system_background_detection },
					stdio = { nil, stdout, stderr },
				}, function(code, _signal)
					stdout:read_stop()
					stderr:read_stop()
					stdout:close()
					stderr:close()
					handle:close()
					handle_spawn_result(code)
				end)
			elseif type(M.config.system_background_detection) == "function" then
				-- Call the function.
				background = M.config.system_background_detection()
				vim.schedule(function()
					callback(background)
				end)
			else
				vim.schedule(function()
					callback(fallback)
				end)
			end
		else
			vim.schedule(function()
				callback(fallback)
			end)
		end
	else
		vim.schedule(function()
			callback(fallback)
		end)
	end
end

-- Determine the active colorscheme based on the schedule.
---@return ColorfulTimes.ParsedScheduleEntry|nil The active schedule entry or nil if none matches.
local function get_active_colorscheme()
	local current_time = get_current_time()
	for _, slot in ipairs(parsed_schedule) do
		local start_time = slot.start_time
		local stop_time = slot.stop_time
		local adjusted_current_time = current_time

		-- Handle overnight schedules.
		if stop_time <= start_time then
			if current_time < start_time then
				adjusted_current_time = adjusted_current_time + 24 * 60
			end
			stop_time = stop_time + 24 * 60
		end

		if adjusted_current_time >= start_time and adjusted_current_time < stop_time then
			return slot
		end
	end

	-- No matching slot found.
	return nil
end

-- Apply the colorscheme.
local function apply_colorscheme()
	local function set_colorscheme(background)
		vim.schedule(function()
			previous_background = background
			vim.o.background = background
			local colorscheme = M.config.default.colorscheme

			if M.config.enabled then
				local active_slot = get_active_colorscheme()
				if active_slot then
					colorscheme = active_slot.colorscheme
				end
			end

			local ok, err = pcall(function()
				vim.cmd.colorscheme(colorscheme)
			end)
			if not ok then
				vim.api.nvim_err_writeln("Failed to apply colorscheme '" .. colorscheme .. "': " .. err)
			end
		end)
	end

	local background = M.config.default.background
	if M.config.enabled then
		local active_slot = get_active_colorscheme()
		if active_slot then
			background = active_slot.background
		end
	end

	if background == "system" then
		-- Compute fallback outside of callback
		local fallback = M.config.default.background ~= "system" and M.config.default.background
			or vim.o.background
			or "dark"
		get_system_background(function(bg)
			set_colorscheme(bg)
		end, fallback)
	else
		set_colorscheme(background)
	end
end

-- Schedule the next colorscheme change.
local function schedule_next_change()
	-- Stop existing timer if any.
	stop_and_close_timer(timer)

	if not M.config.enabled then
		return
	end

	local current_time = get_current_time()
	local min_diff = 24 * 60 -- Maximum possible difference.
	local next_change_in = nil

	for _, slot in ipairs(parsed_schedule) do
		local times = { slot.start_time, slot.stop_time }
		for _, scheduled_time in ipairs(times) do
			local adjusted_time = scheduled_time
			if scheduled_time <= current_time then
				adjusted_time = adjusted_time + 24 * 60
			end
			local diff = adjusted_time - current_time
			if diff > 0 and diff < min_diff then
				min_diff = diff
				next_change_in = diff
			end
		end
	end

	if next_change_in then
		timer = create_timer()
		timer:start(next_change_in * 60 * 1000, 0, function()
			vim.schedule(function()
				apply_colorscheme()
				schedule_next_change()
			end)
		end)
	end
end

-- Start a timer to periodically check the system appearance.
local function start_system_appearance_timer()
	stop_and_close_timer(appearance_timer)

	local sysname = uv.os_uname().sysname or "Unknown"
	if sysname ~= "Darwin" and sysname ~= "Linux" then
		return -- Only implemented for macOS and Linux.
	end

	-- Compute fallback outside of loop callback
	local fallback = previous_background
		or M.config.default.background ~= "system" and M.config.default.background
		or vim.o.background
		or "dark"

	appearance_timer = create_timer()
	appearance_timer:start(0, M.config.refresh_time, function()
		get_system_background(function(current_background)
			if current_background ~= previous_background then
				apply_colorscheme()
			end
		end, fallback)
	end)
end

-- Reload the plugin configuration.
function M.reload()
	M.setup(M.config)
end

-- Toggle the plugin on or off.
function M.toggle()
	M.config.enabled = not M.config.enabled
	if M.config.enabled then
		apply_colorscheme()
		schedule_next_change()
		start_system_appearance_timer()
		vim.notify("Colorful Times enabled.", vim.log.levels.INFO)
	else
		-- Stop any scheduled changes.
		stop_and_close_timer(timer)
		-- Stop the appearance timer.
		stop_and_close_timer(appearance_timer)
		-- Apply default colorscheme and background.
		local background = M.config.default.background
		if background == "system" then
			-- Compute fallback outside of callback
			local fallback = M.config.default.background ~= "system" and M.config.default.background
				or vim.o.background
				or "dark"
			get_system_background(function(bg)
				previous_background = bg
				vim.schedule(function()
					vim.o.background = bg
					pcall(function()
						vim.cmd.colorscheme(M.config.default.colorscheme)
					end)
					vim.notify("Colorful Times disabled.", vim.log.levels.INFO)
				end)
			end, fallback)
		else
			previous_background = background
			vim.o.background = background
			pcall(function()
				vim.cmd.colorscheme(M.config.default.colorscheme)
			end)
			vim.notify("Colorful Times disabled.", vim.log.levels.INFO)
		end
	end
end

-- Setup function to configure the plugin.
---@param opts ColorfulTimes.Config
function M.setup(opts)
	M.config = vim.tbl_deep_extend("force", M.config, opts or {})

	preprocess_schedule()

	-- Apply the colorscheme immediately without deferring.
	apply_colorscheme()

	-- Start timers after initialization.
	vim.defer_fn(function()
		schedule_next_change()
		start_system_appearance_timer()
	end, 0)
end

return M
